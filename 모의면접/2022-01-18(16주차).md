##### 12주차 ~ 15주차 (총 4주차) 
---

## 1. 이벤트 루프 및 동시성 모델에 대해서 설명해주세요.

자바스크립트는 싱글 스레드 기반 언어이다. 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리 할 수 있다.  
하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원한다. (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것)
이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행된다.

---

## 2.  프로토타입이란?

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거(중복 제거 방법은 기존의 코드를 재사용하는것)한다.

즉, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해 놓음으로써 또 구현하는것이 아니라 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.

-   \_ _proto_ \_ 접근자 프로퍼티로 자신의 프로토타입, 즉 Prototype 내부슬롯에 접근 할 수 있음.

-   프로토타입체인이란? 객체의 프로퍼티에 접근하려고 할때 객체에 접근하려는 프로퍼티가 없으면, **proto**접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로로타입체인의 최상위 객체는 Object.prototype이다. 이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다.

-   prototype 프로퍼티 는 생성자함수가 생성할 인스턴스의 프로토타입을 가르킨다.

---

## 3. ES6 에서 추가된 스펙에 대해 아는대로 다 말해주세요.

let, const, 화살표함수, 클래스, 프로미스, 스프레드 연산자 등

-> 이 중에 하나 골라서 꼬리질문 나올 수 있음

ex) 스프레드 연산자란 무엇인가요?

스프레드 연산자를 사용하면 배열, 문자열, 객체 등 반복 가능한 객체 (Iterable Object)를 개별 요소로 분리할 수 있다.

```javascript
const arr = [1, 2, 3];
// 아래와 같이 spread 연산자를 통해 배열을 간단히 합쳐줄 수 있다.
// [1,2,3,1]
console.log([...arr, 1]);
```

## 4. .forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요? 왜 둘 중 하나를 선택할 것인가요?​

forEach

배열의 요소를 반복하며, 각 요소에 대해 콜백을 실행하지만 값을 반환하지 않는 특징이 있다.

```javascript
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
    ...
});
// doubled = undefined
```

map

배열의 요소를 반복하며, 각 요소에서 함수를 호출하여 결과로 새 배열을 작성하여 각 요소를 새 요소에 매핑한다.

```javascript
const a = [1, 2, 3];
const doubled = a.map((num) => {
    return num \* 2;
});
// doubled = [2, 4, 6]
```

.forEach와 .map()의 가장 큰 차이점은 .map()이 새로운 배열을 반환한다는 것이다. 결과가 필요하지만 원본 배열을 변경하고 싶지 않으면 .map(), 단순히 배열을 반복할 필요가 있다면 forEach가 좋은 선택이다.

---

## 5. function foo() {}와 var foo = function() {} 사이에서 foo 사용의 차이에 대해 설명하세요.​

전자는 함수 선언인 반면, 후자는 함수 표현식이다. 주요한 차이점은 함수 선언은 함수바디가 호이스트되지만, 함수 표현식의 바디는 호이스트되지 않는다.(변수와 동일한 호이스팅 동작을 가짐). 함수 표현식을 정의하기 전에 호출하려고 하면 Uncaught TypeError : XXX is not function 에러가 발생한다.

함수 선언

```javascript
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
```

함수 표현식

```javascript
foo(); // Uncaught TypeError: foo는 함수가 아닙니다
var foo = function () {
  console.log("FOOOOO");
};
```

---

## 6. "attribute"와 "property"의 차이점은 무엇인가요?​

attribute는 HTML 마크업에 정의되지만 property는 DOM에 정의된다. 차이점을 설명하기
위해 HTML에 다음 텍스트 필드가 있다고 가정해 보면,

```html
<input type="text" value="Hello" />
```

```javascript
const input = document.querySelector("input");
console.log(input.getAttribute("value")); // Hello
console.log(input.value); // Hello
```

    그러나 텍스트 필드에 "World!"를 입력하면 아래와 같이 된다.

```javascript
console.log(input.getAttribute("value")); // Hello
console.log(input.value); // Hello World!
```

## 7. extends 와 implements 와 abstract 차이

- extends 
사실상 extends가 상속의 대표적인 형태다.
부모에서 선언 / 정의를 모두하여 자식은 메소드 / 변수를 그대로 사용할 수 있다.
'다중상속'을 지원하지 않는다.

- Implements (interface 구현)
부모 객체는 선언만 하며 정의(내용)은 자식에서 오버라이딩(재정의)해서 사용한다.
(extends가 못하는) 다중상속을 대신해준다.

- abstract
extends와 implements의 혼합, extends하되 몇 개는 추상 메서드로 구현되어 있다.


## 8. 자바 컴파일 과정을 설명하세요.

답변: 컴파일러가 소스코드를 자바 바이트코드로(.class) 변환한다, JVM(자바가상머신)이 그 바이트코드를 기계어로 변환하여 인터프리터 방식으로 어플리케이션을 실행한다.

전처리 : #define, #include 지시자 해석
컴파일 : 고급 언어 소스 프로그램 입력받아 어셈블리 파일을 만듦
어셈블 : 어셈블리 파일을 오브젝트 파일로 만듦
링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결
실행

## 9. 멀티 스레드 프로그래밍의 장점은 무엇입니까?

프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다.
스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap(힙) 영역을 이용하여 데이터를 주고받을 수 있다. 그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 심지어 스레드의 context switch(문맥교환)는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다. 따라서 시스템의 성능이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램의 응답 시간이 단축된다. 이러한 장점 때문에 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠 수행하는 것이다.

- 사용자의 반응을 향상시킨다.(= 응답성이 좋다 : 하나의 프로세스에 여러 스레드를 생성하여 스레드에 각기 다른 작업을 하게 함으로써 특정 작업을 하면서도 사용자로부터 명령을 입력받게 할 수 있다.)
- 프로세스 내 리소스 공유하여 경제적이다. (= 자원공유를 효율적으로 할 수 있다.)
- 작업이 분리되어 코드가 간결해진다. 


## 10. 멀티 스레드 프로그래밍의 단점은 무엇입니까?

멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.
그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.

- 구현하기 어렵고, 테스트와 디버깅이 어렵다.
- 전체 프로세스에 영향을 줄 수 있다.  
- 성능 저하가 동반됩니다.
- 동기화 작업이 필요하다.
- 교착상태가 발생하지 않도록 주의해야한다 .

## 11. DB정규화가 무엇인지, 1, 2, 3, BCNF 정규형에 대해 설명해주세요.

정규화란, 테이블 간에 중복된 데이타를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.

1. 제1정규형: 모든 속성 값이 원자 값을 갖도록 분해한다.

2. 제2정규형: 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.
   (여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미한다.)

3. 제3정규형: 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해한다.
   (여기서 이행적 종속이란 A->B->C가 성립하는 것으로, 이를 A,B와 B,C로 분해하는 것이 제3정규형이다.)

4. BCNF 정규형: 제3정규형을 만족하고, 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.

---

## 12. DB 락이 무엇이며, 락의 종류를 설명해주세요.

DB 락은 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구이다.

1. 공유락(LS, Shared Lock): 트랜잭션이 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없다.
2. 베타락(LX, Exclusive Lock): 트랜잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있다.

---

## 13. 트랜잭션의 ACID란 무엇인지 설명해주세요.

1. 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
2. 일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
3. 고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.
4. 지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.


## 14. 데몬(Demon)이란? (2018년 카카오 필기)
리눅스 시스템이 처음 가동될 때 실행되는 백그라운드 프로세스의 일종으로
메모리에 상주하면서 특정 요청이 오면 즉시 대응할 수 있도록 대기 중인
프로세스이다. 윈도우의 서비스(Service)와 유사하다.


. MS윈도우의 서비스(Service)와 유사하고 실제로 '서비스'라고 부르기도 하다. 
보통 리눅스 시스템의 1번 프로세스인 init(PID=1)이 실행하고, 
데몬 프로그램의 명령어는 'd'로 끝난다. (ex. ftpd, mysqld, httpd...)


리눅스 시스템은 주로 서버로서의 역할을 많이 수행하는데 
(요즘은 데스크탑으로도 많이 쓴다만...) 
가령, ftp서버, 웹서버, DB서버 등의 역할을 하는 시스템이라면, 
해당 데몬이 실행중이어야 사용자의 요청을 처리할 수가 있다.


리눅스에서 데몬을 실행하는 방법은 크게 두가지가 있다.
standalone 방식과, super daemon을 통하는 방식이 그것인데, 
일반적으로 빈번히 사용하는 데몬을 standalone 방식으로, 자주 사용하지 않는 데온을 
super daemon방식으로 실행한다. 
만약 리눅스 서버를 웹서버로 사용한다면, 
사용자의 웹 서비스 요청이 매우 빈번히 일어날 것이고, 
따라서 'httpd' 와 같은 웹서버 데몬은 standalone 방식으로 실행한다.

## 15. 프로세스 구성요소에 대해서 설명해주세요
1. PID(Process ID)
PID는 운영체제에서 프로세스를 구분하기 위해서 부여받은 번호를 의미합니다.

2. PPID(Parent Process ID)
PPID는 해당 프로세스를 만든 부모 프로세스의 PID를 의미합니다.
보통 프로그램을 실행한 프로세스가 PPID로 할당됩니다.
예를 들어서 쉘프롬프트에서 명령어을 통해 하나이 프로세스를 실행한다면 해당 프로세스의 PPID는 쉘의 PID가 됩니다.

3. SID(Session ID)
세션(Session)은 여러 프로세스의 묶음을 의미합니다.
SID는 이런 세션을 식별하기위해서 부여되는 번호를 의미합니다.

4. UID(User ID), GID(Group ID)
해당 프로세스를 실행한 사용자의 정보를 나타냅니다.
UID는 사용자의 아이디를 나타내며 0~32767의 숫자로 나타내고 0은 슈퍼(root)유저를 나타냅니다.
그리고 리눅스에서는 사용자를 그룹으로 묶을 수 있는데 이 그룹을 구분지을 수 있는 ID가 GID입니다.

## 16. 링킹과 링커에 대해 설명해주세요(2018 카카오 필기)
링킹(Linking)이란?
하나의 프로그램은 오프벡트 파일과 공용 라이브러리로 조합이 되어 하나의 프로그램이 되며 이렇게
컴퓨터가 실행할 수 있는 프로그램을 만드는 작업을 링킹이라고 한다,
링킹 작업을 마치면 .exe파일이 생성된다.

링커(Linker)란?
링킹작업을 마무리 하면 object 파일이 만들어진다.
이런 오브젝트파일은 기계어로 번역되어집니다. 
이렇게 만들어진 Object file을 링커가 링킹을 해서 exe파일로 만듭니다!

!tip
exe파일을 실행하면 해당프로그램 내용을 메모리에 적재(Load)시키고 프로그램을 수행한다.
이런 일을 수행하는 프로그램을 로더(Loader)라고 한다.
코드 작성 -- (컴파일) --> 오브젝트 파일 -- (링킹) --> 실행 파일 -- (로드) --> 메모리 적재 및 수행

## 17. 커널이 무엇이며 어떤 기능을 하는지 설명해주세요
운영체제의 핵심이며 실행 중 프로그램관리와 시스템에 대한 전반적 자원관리 역할을 수행합니다.
주로 디바이스 관리, 프로세스 관리, 메모리 관리, 시스템 콜 제공과 같은 기능을 가지고 있습니다.


## 18. 리눅스 init 이란 무엇이며 어떤 작업을 수행하는지?

리눅스 리눅스 pc를 부팅 할 때 커널 메모리에 로드되고 여러가지 초기화 과정(하드웨어, 페이지 테이블)이
 정상적으로 이뤄지면 커널은 프로세스들을 만들어 사용자가 컴퓨터가 사용 할 수 있는 환경을 만드는데 
 이때 가장 먼저 만들어 지는 프로세스가 init 프로세스며 커널이 직접 실행하는 유일한 프로세스입니다.

프로레스와 시스템의 초기화 관리를 수행하며 등록된 서비스 혹은 기록된 백그라운드 서비스와 시스템 서비스를 실행합니다.
리눅스의 모든 프로세스는 (Init을 제외하고) 모두 부모 프로세스를 가지게 됩니다.


## 19. 서브네팅이란 무엇이며 필요한 이유는?
네트워크 관리자가 네트워크 성능을 향상시키기 위해, 자원을 효율적으로 분배하는 것
(네트워크 영역과 호스트 영역을 분할 하는 것)

이유 ? 서브넷을 만들지 않고 사용하는 경우 브로드캐스트 도메인이 너무 커져서 
브로드캐스트(같은 네트워크에 있는 모든 장비들에게 보내는 통신)가 너무 많이 발생하게되며,
IP 주소를 아끼기 위해서

####  tip! 
- 유니캐스트? 출발지와 목적지가 정확해야하는 일대일 통신
- 멀티캐스트? 여러명에게 보내야 할 경우에 사용하는 방식으로 유니캐스트와 브로드캐스트를 합쳐놓은 듯한 개념
- 애니캐스트? 가장 가까운 node와 통신하는 방식

## 20. 서브넷 마스크란?
- 서브, 메인이 아닌 어떤 가공을 통한 네트워크를 만들기 위해서 씌우는 마스크
- 주어진 IP 주소를 네트워크 환경에 맞게 나누어 주기 위해서 씌워주는 이진수의 조합

## 21. 서브넷이란?
서브넷 마스크로 만들어진 네트워크이며 하나의 독립된 네트워크이기 때문에 
서로 나뉘어진 서브넷끼리는 라우터를 통해서만 통신이 가능하다.

## 22. 스위치와 라우터의 차이를 설명해주세요.

스위치는 2계층, 라우터는 3계층 장비이다. 스위치는 MAC 주소를 기반으로 통신 노드와 노드 사이의 경로를 지정한다.
라우터는 IP 주소를 기반으로 목적지 호스트까지의 최단 경로를 결정한다.

---

## 23. HTTP Session 동작 순서에 대해 설명해주세요.

1. 클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.

2. 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.

3. 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)한다.

---

## 24. 프록시 서버란 무엇이며, 프록시 서버가 필요한 이유에 대해 설명해주세요.

프록시 서버란, 클라이언트가 자신을 거쳐 다른 네트워크에 접속할 수 있도록 중간에서 대리해주는 서버(서버이면서 동시에 클라이언트)이다.

프록시 서버가 필요한 이유 두 가지

1. 분산 처리 (캐시 사용, 로드밸런싱) - 캐시된 웹페이지가 있으면 프록시 서버에서 바로 클라이언트에 전송
2. 보안 (요청과 응답의 필터링) - 바이러스 검출, 컨텐츠 차단, 웹서버 방화벽


