## 1. VO와 DTO, BO, DAO란?

1. DAO(Data Access Object): DB에 접근하여 실제 데이터를 조회 또는 조작하는 클래스, Repository 또는 Mapper에 해당함

2. BO(Business Object): 여러 DAO를 활용해 비지니스 로직을 처리하는 클래스, Service에 해당함

3. DTO(Data Transfer Object): 데이터를 주고 받기 위해 사용하는 클래스

4. VO(Value Object): 실제 데이터만을 저장하는 클래스

---

## 2. WAS와 WS의 차이에 대해 설명해주세요.

- WAS(Web Application Server): 비지니스 로직을 넣을 수 있음

        Tomcat, PHP, ASP, .Net 등

- WS(Web Server): 비지니스 로직을 넣을 수 없음

        Nginx, Apache 등

---

## 3. Servlet, JSP의 차이점을 설명해주세요.

- Servlet - Container가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것(Html in JAVA)

- JSP(Java Server Page) - html기반에 JAVA코드를 블록화하여 삽입한 것(JAVA in Html)

---

## 4. API와 SDK를 설명해주세요.

응용 프로그램 인터페이스( Application Programming Interface)와 시스템 개발자용 키트(System Developer's Kit)의 약어입니다.

API는 응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스입니다.
ex) 포토샵
-> 포토샵은 매우 유용한 프로그램이지만 얼굴 보정 필터를 탑재하고 있진 않아요.
그래서 포토샵은 이 필터를 개발하려는 사람들을 위해 다양한 인터페이스를 제공하며, 이 인터페이스가 바로 API입니다.
즉, API는 시스템 호출보다 광범위하며 운영체제의 API를 시스템 호출이라고 말할 수 있어요.

SDK는 API 및 API 사용 메뉴얼, 프로그램 개발에 필요한 코드 편집기와 에뮬레이터 등
각종 개발용 응용 프로그램까지 하나로 묶어 배포하는 개발 툴입니다.
한마디로 개발자를 위한 종합 선물 세트죠.
ex) Android Studio

---

## 5. 하이퍼바이저란 무엇인가요?

가상 머신 모니터(Virtual Machine Monitor, VMM)라고도 불리는 하이퍼바이저는 하이퍼바이저 운영 체제와 가상 머신의 리소스를 분리해 VM의 생성과 관리를 지원합니다.

하이퍼바이저로 사용되는 물리 하드웨어를 호스트라고 하며 리소스를 사용하는 여러 VM을 게스트라고 합니다.

하이퍼바이저는 CPU, 메모리, 스토리지 등의 리소스를 처리하는 풀로, 기존 게스트 간 또는 새로운 가상 머신에 쉽게 재배치할 수 있습니다.

모든 하이퍼바이저에서 VM을 실행하려면 메모리 관리 프로그램, 프로세스 스케줄러, I/O(입력/출력) 스택, 기기 드라이버, 보안 관리 프로그램, 네트워크 스택과 같은 운영 체제 수준의 구성 요소가 필요합니다.

하이퍼바이저는 할당되었던 리소스를 각 가상 머신에 제공하고, 물리 리소스에 대해 VM 리소스의 일정을 관리합니다. 물리적 하드웨어는 계속해서 실행 작업을 수행하므로 하이퍼바이저가 일정을 관리하는 동안 CPU가 VM에서 요청한 대로 CPU 명령을 계속 실행합니다.

서로 다른 여러 개의 운영 체제를 나란히 구동할 수 있으며, 하이퍼바이저를 사용해 동일한 가상화 하드웨어 리소스를 공유합니다. 바로 이러한 부분이 가상화의 핵심적인 이점입니다. 가상화가 없다면 하드웨어에서 운영 체제를 1개만 구동할 수 있습니다.

컨테이너와 VM은 유사하다고 볼 수 있습니다. 이 두 가지 모두 다양한 IT 요소를 결합해 시스템의 나머지 부분으로부터 분리하는 패키지 컴퓨팅 환경이기 때문입니다. 중요한 차이점은 확장 방식과 이식성

---

## 6. 프로세스 간 통신이 가능할까요?

> 비동기식 전송
> 비동기식(Asynchronous) 전송은 동기 신호를 포함시켜 데이터를 전송합니다.

송신측의 송신 클록에 관계없이 수신 신호 클록으로 타임 슬롯의 간격을 식별하여 한 번에 한 문자씩 송수신합니다. 이처럼 타이밍을 맞추지 않고 문자 단위로 구분하여 전송하는 것을 비동기식 전송이라 합니다.

이는 시작 비트와 정지 비트 사이의 간격이 가변적이므로 불규칙적인 전송과 짧은 데이터 전송에 적합하며 필요한 접속 장치와 기기들이 간단하므로 동기식정송 장비보다 비용이 저렴합니다. 그러나 시작 비트와 정지 비트를 전송하므로 많은 오버헤드를 갖게 됩니다.

> 동기식 전송
> 동기식(Synchronous) 전송은 한 문자 단위가 아니라 미리 정해진 수 만큼의 문자열을 한 묶음으로 만들어서 일시에 전송합니다.

데이터와는 별도로 송신측과 수신측이 하나의 기준 클록으로 동기 신호를 맞추어 동작하는데, 송신측에서 전송된 데이터를 수신측에서 정확히 수신하기 위해 보내는 측과 받는 측의 타이밍이 일치하는 것을 동기식 전송이라 합니다.

비동기식 전송에 비해 전송효율이 높지만 수신측에서 문자를 조립하여 별도의 비트 계산을 하는 기억장치가 필요하므로 많은 비용이 듭니다.

---

## 7. DNS의 Round Robin 방식을 설명해주세요.

-> L4 스위치 같은 로드밸런싱 장비가 부담이 될 때 저렴하고 간단하게 서버 분산을 구현하는 방법입니다.
클라이언트 세션을 유지하며 처음 연결한 서버에 지속적으로 연결해주는 기능은 없습니다.
간단한 요청과 결과로만 이루어진 페이지들이라면 사용할 수 있습니다.
서버가 A, B, C 3대가 있으면 첫 요청에 A, 다음엔 B, 다음에 C로 연결하고 이후엔 다시 A-B-C 절차를 반복합니다.

---

## 8. 모노레포에 대해서 설명해주세요

-> 모노레포(Monorepo)는 두 개 이상의 프로젝트 코드를 하나의 저장소에서 관리하는 기법입니다.

- 코드의 재사용 : 여러 저장소에서 프로젝트를 진행하면 비슷한 로직을 각 저장소에서 중복 구현하는 때가 많은데, 이를 공유하려면 저장소와 의존성을 추가해야 합니다. 모노레포를 적용하는 경우 하나의 저장소에서 하나의 키워드만으로 모든 프로젝트가 같은 공통 코드를 사용할 수 있습니다.

- 의존성 관리: 멀티레포 구조에서는 각 저장소에 Linter를 따로 설치했지만 모노레포를 적용하면 그럴 필요가 없습니다.

- 작은 커밋과 PR: 모노레포에서는 여러 패키지의 변경사항을 하나의 커밋과 PR로 제출할 수 있어 작업을 작게 쪼갤 수 있습니다. 물론 하나의 커밋에는 한 패키지의 변경사항만 기록하는 SRP(Single Responsibility Principle, 단일 책임 원칙)를 지켜야하죠.

- 대규모 리팩토링: 모노레포로 저장소를 운영해보니 하나의 파일에 대한 컨트리뷰터가 상당히 많아지므로 해당 로직을 이해하는 여러 사람이 효율적으로 작성하는 방식에 대해서도 함께 생각할 수 있으므로 대규모 리팩토링을 유도할 수 있습니다.

- 팀 간 협업: 모든 구성원이 모든 코드에 접근할 수 있기 때문에 팀 간 협업이 자유롭습니다.

- 트렁크 기반 개발(Trunk Based Development): 모노레포에서는 서버와 웹을 합쳐 하나의 버전으로 판단할 수 있으므로 Master 브랜치를 항상 배포할 수 있도록 유지하는 트렁크 기반 개발에 도움이 됩니다.

---

## 9. CI / CD는 무엇인가요?

-> CI는 개발자를 위한 자동화 프로세스인 지속적인 통합(Continuous Integration)이며, CD는 지속적인 서비스 제공 또는 지속적인 배포입니다.

---

## 10. 트리거란?

자동으로 실행되도록 정의된 저장 프로시저

insert, update, delete문에 대한 응답을 자동으로 호출한다.

사용하는 이유는?
업무 규칙 보장, 업무 처리 자동화, 데이터 무결성 강화

---

## 11. 사용자 수준 스레드 vs 커널 수준 스레드 차이는?

- 사용자 수준 스레드

  장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)

  단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)

- 커널 수준 스레드

  장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음

  단점 : context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.

  ***

## 12. Race Condition이란?

두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황

Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

---

## 13. Module Bundler란?

여러 개의 나누어져 있는 파일들을 하나의 파일로 만들어주는 라이브러리(wepback, Parcel 등)

### 왜 나옴?

모듈 번들러 개념이 없었을 때 웹페이지에 접속했다고 가정

→ 이때 웹페이지에서는 페이지를 보여주기 위한 수 많은 자바스크립트 파일을 서버에 요청

→ 이를 통해 웹페이지를 보여주기 위해 서버와 여러 번 통신하게 되는 게 비효율적임

위와 같은 문제를 해결하기 위해 생김

하지만 지원을 안 해주는 브라우저들도 있기 때문에 웹팩과 같은 모듈 번들러 라이브러리가 브라우저들이 지원할 수 있는 코드로 변환해야 함

---

## 14. 자바스크립트 반복문의 종류와 사용법에 대해 설명해주세요.

### 1. for in : 객체의 프로퍼티 키 열거 전용

```javascript
var obj = {
  a: 1,
  b: 2,
  c: 3,
};

for (var item in obj) {
  console.log(item); // a, b, c
}

//만약 for ...of 를 쓴다면
var obj = {
  a: 1,
  b: 2,
  c: 3,
};

for (var item of obj) {
  console.log(item); // Uncaught TypeError: obj is not iterable
}
```

## 2. for of : 배열 이터러블 순회 전용

```javascript
var arr = [1, 2, 3];

for (var item of arr) {
  console.log(item); // 1, 2, 3
}

//만약 for ...in 를 쓴다면
var arr = [1, 2, 3];

for (var item in arr) {
  console.log(item); // 0, 1, 2
}
```

## 3. Object 객체 메서드: 객체 순회 전용

```javascript
1) Object.keys(객체)
: 객체의 프로퍼티 '키'를 배열로 반환

Object.keys({name:'curryyou', job:'engineer'});
// [ 'name', 'job' ]


2) Object.values(객체)
: 객체의 프로퍼티 '값'을 배열로 반환

Object.values({name:'curryyou', job:'engineer'});
// [ 'curryyou', 'engineer' ]


3) Object.entries(객체)
: 객체의 프로퍼티 [키, 값]을 배열로 반환

Object.entries({name:'curryyou', job:'engineer'});
// [ [ 'name', 'curryyou' ], [ 'job', 'engineer' ] ]
```

## 4. Array.prototye 메서드 : 배열 전용(4종류)

```javascript
1) 배열.forEach( (value, index, array)=>{...반복 수행 코드...} )
: 배열의 length만큼 반복하여 콜백함수를 호출한다.
: 콜백함수의 매개변수로 value에 요소값, index에 인덱스, array에 원본배열이 들어온다.

[1, 2, 3, 4].forEach((value, index, array)=>{
    console.log(value);  // 1, 2, 3, 4 출력
})


2) 배열.map( (value, index, array)=>{...반복 수행 코드...} )
: forEach와 동일(순회 방식, 콜백함수 매개변수 등)
: 다른점 => 각 콜백함수에서 return 하는 값들으로 새로운 배열을 만들어 반환한다.

const map_reuslt = [1, 2, 3, 4].map((value, index, array)=>{
    console.log(value); // 1, 2, 3, 4 출력
    return value*10; // 각 요소에 10을 곱한 값을 배열로 반환
})

console.log(map_reuslt);
// [ 10, 20, 30, 40 ]


3) 배열.filter( (value, index, array)=>{...반복 수행 코드...} )
: forEach와 동일(순회 방식, 콜백함수 매개변수 등)
: 다른점 => 각 콜백함수에서 return하는 값이 true일 때만, 그때의 value 값들로 새로운 배열을 만들어 반환한다.

const filter_result = [1, 2, 3, 4].filter((value, index, array)=>{
    console.log(value); // 1, 2, 3, 4 출력
    return value%2 == 0; // value가 짝수인 값들을 배열로 반환
})

console.log(filter_result);
// [ 2, 4 ]


4) 배열.reduce( (previousValue, currentValue, currendIndex, array)=>{...반복 수행 코드...}, initialValue )
: 두번째 매개변수인 initialValue값을 시작으로,
: 각 콜백함수가 return하는 값이 다음에 실행되는 콜백함수의 previousValue로 들어간다.
: 최종적으로 마지막 콜백함수가 return하는 값을 반환한다.(아래의 코드를 보면 이해가 잘 됨.)

const reduce_result = [1, 2, 3, 4].reduce((pv, cv, idx, arr)=>{
    return pv + cv; // 이전 콜백함수가 리턴한 값에 현재의 요소 값을 더함(누적 개념)
}, 100); // 100을 초기값으로 줌

console.log(reduce_result);
// 110 (100 + 1 + 2 + 3 + 4 결과)
```

---

## 15. 위에서 파생된 질문: 객체 배열에서 속성들 중 최대 값을 찾으려면, 어떻게 코드를 짜는 것이 효율적인가요? (data는 주어진다고 가정)

```javascript
/* data 👇🏻
[
  {
    "x": "8/11/2009",
    "y": 0.026572007
  },
  {
    "x": "8/12/2009",
    "y": 0.025057454
  },
  {
    "x": "8/13/2009",
    "y": 0.024530916
  },
  {
    "x": "8/14/2009",
    "y": 0.031004457
  }
]
*/

답변

1) reduce 사용

const max = data.reduce(function(prev, current) {
    return (prev.y > current.y) ? prev : current
})

2) map 사용
const maxValueOfY = Math.max(...arrayToSearchIn.map(o => o.y), 0);

```

---

## 16. 웹서버와 WAS의 차이점?

-> 웹서버는 Http 프로토콜을 기반으로, 클라이언트의 요청을 서비스하는 기능을 담당하며 Apache,Nginx 등이 있고, 정적 컨텐츠만 처리하도록 기능 분배를 해서 서버 부담을 줄입니다.

WAS는 Web Application Server 약자로 DB조회 및 다양한 로직 처리 요구시 동적인 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버입니다. WAS는 요청에 맞는 데이터를 디비에서 가져와 비즈니스 로직에 맞게 그때마다 결과를 만들고 제공하면서 자원을 효율적으로 사용 할 수 있습니다.

-> 따라서, 자원 이용의 효율성 및 장애 극복 등의 이유로 둘을 분리해서 사용합니다.

---

## 17. #Race Condition이란?

두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓸 때, 공용 데이터에 대한 접근이 순서에 따라 실행 결과가 달라지는 상황

Race Condition이 발생하게 되면, 모든 프로세스에 원하는 결과가 발생하는 것을 보장할 수 없음. 따라서 이러한 상황은 피해야 하며 상호배제나 임계구역으로 해결이 가능하다.

---

## 18. 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함

프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함

대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.

---

## 19. 페이지 부재란 무엇인가요?

-> 프로세스가 가상 메모리의 페이지 테이블에 있는 페이지를 요청했을 때 그 페이지가 메모리에 없는 경우를 페이지 폴트라고 합니다. 페이지 폴트가 발생하면 프레임을 새로 할당 받아야 하며, 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 합니다.

---

## 20. 문맥 전환(Context Switching)이 무엇인가요?

-> CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서, 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(context)을 교체하는 작업을 context switching이라고 합니다.

---

## 21. '기아현상(Starvation)'과 '노화기법(Aging)'이 무엇인지 각각 설명해주세요

-> 기아현상은 자원관리 문제로 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 현상을 말합니다.
노화기법은 이러한 기아현상을 방지하는 기법이며 특정 프로세스의 우선순위가 낮아 무한정 기다리게 된다면, 한번 양보하거나 기다린 시간에 비례하여 우선순위를 높여 자원을 할당받을 수 있도록 해주는 기법입니다.

---

## 22. SSL(TLS)란 무엇인지 설명해주세요.

Secure Sockets Layer은 암호규악이다.

( 영어: Transport Layer Security, TLS )

( 과거 명칭: 보안 소켓 레이어/Secure Sockets Layer, SSL )

SSL과 TLS는 같은 뜻으로 말하며 TLS1.0은 SSL3.0을 계승한다. 쉽게 생각하면 SSL의 New Version이 TLS이다. 하지만 TLS라는 이름보단 SSL이라는 이름으로 더 많이 사용되고 있다.

1. SSL(TLS)는 클라이언트/서버 응용 프로그램이 네트워크로 통신을 하는 과정에서 도청, 간섭, 위조를 방지하기 위해서 설계되었다. 또한 암호화를 해서 최종단의 인증, 통신 기밀성을 유지시켜준다.

2. SSL 인증서란 클라이언트와 서버간의 통신을 제 3자가 보증을 해주는 문서이다. 클라이언트가 서버에 접속하면, 서버는 클라이언트에게 인증서를 전달한다. 그러면 클라이언트는 이 인증서를 보고 신뢰할 수 있는 사람인지 확인 후 데이터를 보내는 등 다음 절차를 수행하게 된다.

---

## 23. DNS란 무엇인지 설명해주세요.

인터넷에 연결되어 있는 장치들은 각각의 장치를 식별할 수 있는 주소를 가지고 있는데 이를 ip주소라고 한다.

ip주소는 111.22.33.44 와 같은 숫자형식으로 되어 있는데 이는 사람이 기억하기 매우 어렵다. 이러한 어려움에 따라 도메인이 등장하게 되었는데 도메인은 바로 이러한 숫자들을 우리가 기억하기 쉽게 이름을 부여하는 것을 말한다. 예를들면, www.naver.com이 바로 도메인이다. 즉, 이러한 인터넷 주소창에 Host Domain Name을 입력했을 때(ex, naver.com, google.com 등..) 해당 문자를 IP주소로 변환해 주는 시스템을 말한다.

---

## 24. 프록시 서버와 VPN의 차이점에 대해 설명해주세요.

1. 프록시 서버와 달리 VPN은 트래픽을 안전하게 암호화한다. VPN을 사용하면 인터넷 업체의 추적과 정부의 감시를 피하고 해킹 공격을 방지할 수 있다. 반면에 프록시 서버는 트래픽을 완벽히 암호화할 수 없으므로 중요 정보를 관리할 때는 적합하지 않은 서비스다.

2. VPN은 운영 체제 수준에서 동작해 모든 트래픽을 라우팅한다. 반면에 프록시 서버는 응용프로그램 수준에서 동작하며 특정 앱 또는 브라우저의 트래픽만 라우팅할 수 있다.

3. 프록시 서버에서는 연결 중단이 자주 발생하는 반면 VPN 서버의 연결은 상대적으로 안정적이다.

---

## 25. IPv4와 IPv6의 차이점은 무엇인가요?

-> IPv4는 32비트로 구성되어있고, 현재 IPv4의 IP 주소가 고갈되어 신규할당이 전면 중단되었습니다. IPv6는 128비트의 주소 체계를 가집니다.

---

## 26. SSH란 무엇인가요?

-> `시큐어 셸(Secure Shell, SSH)`은 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해 주는 응용 프로그램 또는 그 프로토콜을 가리킵니다. SSH는 암호화 기법을 사용하기 때문에, 통신이 노출된다고 하더라도 이해할 수 없는 암호화된 문자로 보입니다.

---

## 27. MAC 주소란 무엇이고, 어떻게 구성되어 있나요?

-> MAC 주소란 모든 네트워크 장비나 LAN카드에 새겨진 물리적 주소 입니다. LAN 영역에서 내부통신을 위해 사용됩니다. IP주소가 있는데 MAC주소까지 사용하는 이유는 IP는 DHCP 서버에 의해 유동적이라 호스트 구분이 불가능하기 때문입니다.
