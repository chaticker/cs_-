## 1. 클로저(Closure)란 무엇이며, 왜 이러한 패턴을 사용하는가

#### 답변

자바스크립트는 함수 안에서도 함수를 선언 할 수 있다. 전자를 외부함수라 정의하고 후자를 내부함수라 정의해보면 기본적으로 내부함수는 외부함수의 요소에 접근이 가능한데 외부함수에서 그 함수의 수명이 다 하여 외부함수가 종료된 후에도 외부함수의 변수에 내부함수가 접근 할 수 있는 메커니즘을 클로져라고 한다.

---

## 2. Vue 라이프사이클에 대해 설명해주세요.

#### 답변

-   new Vue()

    실행시 vue의 인스턴스를 생성한다.

-   beforecreate

    Vue의 라이프사이클 훅중에서 가장먼저 실행되는 훅으로, data와 events(vm.on,vm.once, vm.off,vm.emit)가 설정되기 전에 실행되기 때문에 사용시 오류가 난다.

-   created

    data와 methods, computed 들이 완성된 시점이기 때문에 해당 event를 사용할 수 있다. 주로 서버와의 데이터처리에서 많이 사용되는 훅이다.

-   beforeMounted

    아직 DOM에 접근할수 없는 단계로, 보통 data처리는 created에서 처리하기때문에 거의 사용하지 않는다.

-   mounted

    DOM에 접근할 수 있는 단계로, 이말은 모든 DOM이 생성된 이후에 접근가능하다는 말이다.

-   beforeUpdated

    업데이트 된 값들을 가지고 있는 상태이기 때문에, 업데이트 된 값으로 다른 값들을 업데이트 할 수 있다.

-   updated

    컴포넌트의 데이터가 변하여 재 렌더링이 일어나 후에 실행된다. mounted와 마찬가지로 돔이 업데이트 완료된 상태이므로 돔 종속적인 연산을 할 수 있다.

-   beforedestroy

    컴포넌트 해체되기 전 호출된다. Destroyed가 호출되기전에 주로 이벤트 리스너를 제거할 때 많이 사용한다.

-   detroyed

    모든 컴포넌트 해체되고 난 후 호출되는 훅으로, 컴포넌트의 모든 리스너가 해제되고 자식컴포넌트까지 해제된다.

---

## 3. null과 undefined의 차이에 대해 설명해주세요.

#### 답변

이 두 타입은 모두 기본적으로는 '값이 없음'을 의미한다. 그 중 undefined는 값이 할당되지 않은 변수를 의미한다. 즉 var나 let 등의 키워드를 통해 신규 생성된 변수의 기본값은 undefined라는 의미이다.

null은 명시적으로 값이 비어있음을 나타내는데 사용한다. 아무것도 참조하고 있지 않은 변수라는 의도를 직접적으로 반영하고자 할 때 null을 사용한다.

---

## 4. ’==’와 ‘===’의 차이

#### 답변

-   '=='연산자는 동등 연산자로, 피연산자가 서로 다른 타입이면 타입을 강제로 변환시켜 비교한다.

    '1' == 1 // true

-   '===' 연산자는 일치 연산자로, 두 피연산자를 더 정확하게 비교한다.

    '1' === 1 //false

    ***

## 5. 타입과 인터페이스의 차이에 대해서 설명해주세요

#### 답변

인터페이스는 자신의 이름을 중복 선언하여 extends 키워드를 사용하지 않더라도 확장이 가능하지만,
타입의 경우 중복 선언을 통해 확장할 수 없다. (& 연산자를 사용하여 확장해야 한다)
객체에만 쓰는 용도라면 interface를 사용하는 것이 좋을 것이다.

---

## 6. Call, Apply, Bind 함수에 대해 설명해주세요 (차이점 포함)

#### 답변

this가 함수 호출식에 따라 객체를 가르킨다면 call, apply, bind는 함수가 직접 실행문맥을 결정한다. 그 중에 call, apply는 함수를 호출해 실행하는데, 둘의 차이점은 call은 함수에서 지정된 파라미터 형식대로 받지만, apply는 함수의 파라미터를 배열 형태로 넣어야 된다는 것이 차이점이다. bind는 이 둘과 다르게 새 함수를 만들어 변수에 저장한다.

---

## 7. 이벤트 루프 및 동시성 모델에 대해서 설명해주세요.

#### 답변

자바스크립트는 싱글 스레드 기반 언어이다. 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리 할 수 있다.  
하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원한다. (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것)
이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행된다.

---

## 8. 프로토타입이란?

#### 답변

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거(중복 제거 방법은 기존의 코드를 재사용하는것)한다.

즉, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해 놓음으로써 또 구현하는것이 아니라 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.

-   \_ _proto_ \_ 접근자 프로퍼티로 자신의 프로토타입, 즉 Prototype 내부슬롯에 접근 할 수 있음.

-   프로토타입체인이란? 객체의 프로퍼티에 접근하려고 할때 객체에 접근하려는 프로퍼티가 없으면, **proto**접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로로타입체인의 최상위 객체는 Object.prototype이다. 이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다.

-   prototype 프로퍼티 는 생성자함수가 생성할 인스턴스의 프로토타입을 가르킨다.

---

## 9. ES6 에서 추가된 스펙에 대해 아는대로 다 말해주세요.

#### 답변

let, const, 화살표함수, 클래스, 프로미스, 스프레드 연산자 등

-> 이 중에 하나 골라서 꼬리질문 나올 수 있음

ex) 스프레드 연산자란 무엇인가요?

스프레드 연산자를 사용하면 배열, 문자열, 객체 등 반복 가능한 객체 (Iterable Object)를 개별 요소로 분리할 수 있다.

```javascript
const arr = [1, 2, 3];
// 아래와 같이 spread 연산자를 통해 배열을 간단히 합쳐줄 수 있다.
// [1,2,3,1]
console.log([...arr, 1]);
```
